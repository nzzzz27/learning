# DI（依存性の注入）
互いに依存させないために、コンポーネントを分けてそれをお互いに注入する方法。  
Play frameworkは、[JSR330](https://jcp.org/en/jsr/detail?id=330)に基づくランタイム依存性注入を提供している。ランタイム依存関係注入は、依存関係グラフが作成され、実行時に関連付けられ、検証されるため、このように呼ばれます。

用語：ランタイム    
> アプリケーションの開発・実行の両方の機能を備えたソフトウェアから、開発の機能を省き、実効の機能のみを取り出したプログラムのことである。 ランタイムは、アプリケーションを実行するために必要な単体プログラムのほか、開発ツールを用いて開発したファイル群を意味することもある。

[IT用語辞典バイナリ](https://www.weblio.jp/content/%E3%83%A9%E3%83%B3%E3%82%BF%E3%82%A4%E3%83%A0#:~:text=%E3%83%A9%E3%83%B3%E3%82%BF%E3%82%A4%E3%83%A0%E3%81%A8%E3%81%AF%E3%80%81%E3%82%A2%E3%83%97%E3%83%AA%E3%82%B1%E3%83%BC%E3%82%B7%E3%83%A7%E3%83%B3%E3%81%AE,%E6%84%8F%E5%91%B3%E3%81%99%E3%82%8B%E3%81%93%E3%81%A8%E3%82%82%E3%81%82%E3%82%8B%E3%80%82)

## Declaring Dependencies 
コントローラのようなコンポーネントが他のコンポーネント依存性として必要とする場合、`@Inject`アノテーションを使用することができる。`@Inject@アノテーションは、フィールドまたはコンストラクタで使用することができ、**コンストラクタで使用することが推奨されている。**  

`@Inject`アノテーションの書き方：  
クラス名とコンストラクタの間にに、`()`付きで記載する

```
import javax.inject._
import play.api.libs.ws._

class MyComponent @Inject() (ws: WSClient) {
  // ...
}
```

## Dependency injecting controllers 
PlayでDependency injecting controllersを利用するには、2つの方法がある。  

### Injected routes generator 
Playは、デフォルトでは全てのメゾットはstaticとみなしてstatic routerを生成する。  
Playでinjected routes generatorを指定することで、Playにルーティング先のすべてのコントローラーを依存関係として宣言するルーターを生成させ、コントローラーに依存関係を注入できるようにすることができる。  
**公式では、injected routes generatorの利用を常に推奨している。**  

injected routes generatorを有効にするには、以下を`build.sbt`ファイルに記載する。  
```
routesGenerator := InjectedRoutesGenerator
```

注入されたルートジェネレータを使用する場合、アクションの前に@記号を付けると、**コントローラーに直接注入されるのではなく、コントローラーのプロバイダに注入されることになる**。これにより、例えば、コントローラーのプロトタイプを作成したり、周期的な依存関係を解消したりできる。  

### Injected actions 
もしstatic routes generatorを使用しているなら、次のように、アクションの前に@を付けることで、アクションに注入されたコントローラーがあることを示すことができる。  

```
GET        /some/path           @controllers.Application.index
```

## Component lifecycle 
依存性注入システムは、注入されたコンポーネントのライフサイクルを管理し、必要に応じてそれらを作成し、それらを他のコンポーネントに注入する。コンポーネントのライフサイクルの仕組みは次のとおり。  

### コンポーネントが必要になるたびに新しいインスタンスが作成されます
コンポーネントが複数回使用される場合、デフォルトでは、コンポーネントの複数のインスタンスが作成されます。コンポーネントの単一インスタンスのみが必要な場合は、それをシングルトンとしてマークする必要があります。  

### インスタンスは必要なときに遅延して作成されます。
コンポーネントが別のコンポーネントで使用されない場合、コンポーネントはまったく作成されません。これは通常必要なものです。ほとんどのコンポーネントでは、必要になるまでコンポーネントを作成しても意味がありません。  
ただし、場合によっては、コンポーネントをすぐに起動したい場合や、コンポーネントが別のコンポーネントで使用されていない場合でも起動する必要があります。  
たとえば、アプリケーションの起動時にメッセージをリモートシステムに送信したり、キャッシュをウォームアップしたりできます。 Eagerバインディングを使用して、コンポーネントを強制的に作成することができます。  

### 通常のガベージコレクションを超えて、インスタンスが自動的にクリーンアップされない
コンポーネントは、参照されなくなったときにガベージコレクションされますが、フレームワークは、closeメソッドの呼び出しなど、コンポーネントをシャットダウンするために特別なことを行いません。  
ただし、PlayはApplicationLifecycleと呼ばれる特別なタイプのコンポーネントを提供します。これにより、アプリケーションが停止したときにシャットダウンするコンポーネントを登録できます。  


## [Singleton](https://docs.oracle.com/javaee/7/api/javax/inject/Singleton.html)
キャッシュや外部リソースへの接続など、状態を保持するコンポーネントがある場合や、コンポーネントの作成にコストがかかる場合があります。これらのケースでは、そのコンポーネントのインスタンスが1つだけであることが重要な場合があります。  
これは、@ Singletonアノテーションを使用して実現できます。  

```
import javax.inject._

@Singleton
class CurrentSharePrice {
  @volatile private var price = 0

  def set(p: Int) = price = p
  def get = price
}
```

## Stopping / cleaning up

